## 如何手写一个堆

+ 插入一个元素					heap[++size]=x;up(size);
+ 求集合当中的最小值         heap[1]
+ 删除最小值 				       heap[1]=heap[size--]; down(1)
+ 删除任意一个元素 			heap[k]=heap[size--];down(k),up(k);
+ 修改任意一个元素			 heap[k]=x;down(k),up(k);



> 下标从1开始



### [838.堆排序](https://www.acwing.com/problem/content/840/)

```c++
#include<iostream>
#include <algorithm>
using namespace std;
const int N=100010;
int cnt,h[N];

void down(int t){	//down操作
    int u=t;
    if(u*2<=cnt&&h[u*2]<h[t])t=2*u;
    if(u*2+1<=cnt&&h[u*2+1]<h[t])t=2*u+1;
    if(t!=u){
        swap(h[u],h[t]);
        down(t);
    }
}

void up(int u){		//up操作
   	while(u/2&&h[u/2]>h[u]){
        swap(h[u/2],h[u]);
        u/=2;
    }
}
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)scanf("%d",&h[i]);	
    cnt=n;
    for(int i=n/2;i;i--)down(i);	//建堆操作
    while(m--){
        printf("%d ",h[1]);
        h[1]=h[cnt--];
        down(1);
    }
    puts("");
    return 0;
}
```

### 前提：左右子树都是小堆，根节点这棵树不满足那么可以使用向下调整算法

**估算向下调整最多调整多少次？(log2N)**



### [838. 堆排序](https://www.acwing.com/problem/content/840/)

```c++
//下标从0开始
//始终保持堆的结构
//父节点：i
//左儿子：i*2+1
//右儿子：i*2+2

//儿子：i
//父节点：(i-1)/2
//所以从cnt-1=i  所以最后一个结点为(i-1)/2=(cnt-2)/2=cnt/2-1 为啥要从最后一个结点的父亲节点开始建堆
//因为向下调整的前提是左右子树都是小堆，所以只能从后往前建立，才能保证之后用到的小堆都是建立好了的
#include<iostream>
using namespace std;
const int N=100010;
int cnt,h[N];

void down(int u){
    int t=u;
    if(u*2+1<cnt&&h[t]>h[2*u+1])t=u*2+1;
    if(2*u+2<cnt&&h[t]>h[2*u+2]) t=u*2+2;
    if(u!=t){
        swap(h[u],h[t]);
        down(t);
    }
}
void up(int u){
    
    while((u-1)/2&&h[(u-1)/2]>h[u]){
        swap(h[(u-1)/2],h[u]);
        u=(u-1)/2;
    }
}
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=0;i<n;i++)scanf("%d",&h[i]);
    cnt=n;
    
    for(int i=n/2-1;i>=0;i--) down(i);
    while(m--){
        printf("%d ",h[0]);
        h[0]=h[--cnt];
        down(0);
    }
    return 0;
}

```



### [面试题 17.14. 最小K个数](https://leetcode-cn.com/problems/smallest-k-lcci/)

```c++
class Solution {
public:
    int cnt;
    void down(vector<int>& arr, int u) {
        int t = u;
        if (2 * u + 1 < cnt && arr[t] > arr[u * 2 + 1])t = 2 * u + 1;
        if (2 * u + 2 < cnt && arr[t] > arr[u * 2 + 2])t = 2 * u + 2;
        if (u != t) {
            swap(arr[t],arr[u]);
            down(arr,t);
        }
    }
    vector<int> smallestK(vector<int>& arr, int k) {
        if (arr.size() == 0)return arr;
        vector<int> res;
        cnt = arr.size();
        for (int i = cnt / 2 - 1; i >= 0; i--) down(arr, i);
        while (k--) {
            res.push_back(arr[0]);
            arr[0] = arr[--cnt];
            down(arr,0); 
        }
        return res;
    }
};
```




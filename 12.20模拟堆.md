## 如何手写一个堆

+ 插入一个元素					heap[++size]=x;up(size);
+ 求集合当中的最小值         heap[1]
+ 删除最小值 				       heap[1]=heap[size--]; down(1)
+ 删除任意一个元素 			heap[k]=heap[size--];down(k),up(k);
+ 修改任意一个元素			 heap[k]=x;down(k),up(k);



> 下标从1开始



### [838.堆排序](https://www.acwing.com/problem/content/840/)

```c++
#include<iostream>
#include <algorithm>
using namespace std;
const int N=100010;
int cnt,h[N];

void down(int t){	//down操作
    int u=t;
    if(u*2<=cnt&&h[u*2]<h[t])t=2*u;
    if(u*2+1<=cnt&&h[u*2+1]<h[t])t=2*u+1;
    if(t!=u){
        swap(h[u],h[t]);
        down(t);
    }
}

void up(int u){		//up操作
   	while(u/2&&h[u/2]>h[u]){
        swap(h[u/2],h[u]);
        u/=2;
    }
}
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)scanf("%d",&h[i]);	
    cnt=n;
    for(int i=n/2;i;i--)down(i);	//建堆操作
    while(m--){
        printf("%d ",h[1]);
        h[1]=h[cnt--];
        down(1);
    }
    puts("");
    return 0;
}
```



### [839.模拟堆](https://www.acwing.com/problem/content/841/)

```c++

```


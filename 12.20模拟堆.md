## 如何手写一个堆

+ 插入一个元素					heap[++size]=x;up(size);
+ 求集合当中的最小值         heap[1]
+ 删除最小值 				       heap[1]=heap[size--]; down(1)
+ 删除任意一个元素 			heap[k]=heap[size--];down(k),up(k);
+ 修改任意一个元素			 heap[k]=x;down(k),up(k);



> 下标从1开始



### [838.堆排序](https://www.acwing.com/problem/content/840/)

```c++
#include<iostream>
#include <algorithm>
using namespace std;
const int N=100010;
int cnt,h[N];

void down(int t){	//down操作
    int u=t;
    if(u*2<=cnt&&h[u*2]<h[t])t=2*u;
    if(u*2+1<=cnt&&h[u*2+1]<h[t])t=2*u+1;
    if(t!=u){
        swap(h[u],h[t]);
        down(t);
    }
}

void up(int u){		//up操作
   	while(u/2&&h[u/2]>h[u]){
        swap(h[u/2],h[u]);
        u/=2;
    }
}
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)scanf("%d",&h[i]);	
    cnt=n;
    for(int i=n/2;i;i--)down(i);	//建堆操作
    while(m--){
        printf("%d ",h[1]);
        h[1]=h[cnt--];
        down(1);
    }
    puts("");
    return 0;
}
```



### [316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

```c++
class Solution {
public:
    string removeDuplicateLetters(string s) {
        string res = "";	//用string 模拟单调栈
        vector<int> cnt(26);
        vector<bool> vis(26,false);	//判断元素是否以及出现过
        for (auto ch : s)cnt[ch - 'a']++;	//统计元素的个数
        for (auto ch : s) {
            cnt[ch - 'a']--;	
            if (vis[ch - 'a'])continue;	//出现过直接结束这次循环
            while (!res.empty()&&cnt[res.back()-'a']&&res.back()>ch) {	//判断栈是否为空并且栈顶元素是否还会出现过，栈顶元素是否大于当前元素
                vis[res.back() - 'a'] = false;//将出现过标记为没有出现
                res.pop_back();	
            }
            vis[ch - 'a'] = true;	
            res += ch;
        }
        return res;
    }
};

```